<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Plugin">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Plugin: SpecializedPlugin&lt; SpecInterface &gt; Class Template Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Plugin</h1>
        <h2>API Reference</h2>
        <div class="version">
        2.0.3
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1plugin.html">plugin</a></li><li class="navelem"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html">SpecializedPlugin&lt; SpecInterface &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SpecializedPlugin&lt; SpecInterface &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class allows <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> instances to have high-speed access to interfaces that can be anticipated at compile time. The plugin does not have to actually offer the specialized interface in order to get this performance improvement. This template is variadic, so it can support arbitrarily many interfaces.  
 <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gz_2plugin_2SpecializedPlugin_8hh_source.html">SpecializedPlugin.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> () const</td></tr>
<tr class="memdesc:af00a56f400aaf960349d00e50d8effd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface.  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#af00a56f400aaf960349d00e50d8effd5">More...</a><br /></td></tr>
<tr class="separator:af00a56f400aaf960349d00e50d8effd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> () const</td></tr>
<tr class="separator:af00a56f400aaf960349d00e50d8effd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024cf112587cb3f084508c8bc6ea1bc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a024cf112587cb3f084508c8bc6ea1bc7">HasInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName, const bool _demangled=true) const</td></tr>
<tr class="memdesc:a024cf112587cb3f084508c8bc6ea1bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface.  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a024cf112587cb3f084508c8bc6ea1bc7">More...</a><br /></td></tr>
<tr class="separator:a024cf112587cb3f084508c8bc6ea1bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface</a> ()</td></tr>
<tr class="memdesc:aa5a5071a558207e3853ee0de5f5bcf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interface of the specified type, if it is provided by this plugin.  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">More...</a><br /></td></tr>
<tr class="separator:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface</a> ()</td></tr>
<tr class="separator:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aed5dc9dd27c987508c981e6758901977">QueryInterface</a> () const</td></tr>
<tr class="memdesc:aed5dc9dd27c987508c981e6758901977"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-qualified version of <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface&lt;Interface&gt;()</a>  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aed5dc9dd27c987508c981e6758901977">More...</a><br /></td></tr>
<tr class="separator:aed5dc9dd27c987508c981e6758901977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aed5dc9dd27c987508c981e6758901977">QueryInterface</a> () const</td></tr>
<tr class="separator:aed5dc9dd27c987508c981e6758901977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr</a> ()</td></tr>
<tr class="memdesc:a2d7fa223a00dd4318c553261a71f7667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined.  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">More...</a><br /></td></tr>
<tr class="separator:a2d7fa223a00dd4318c553261a71f7667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr</a> ()</td></tr>
<tr class="separator:a2d7fa223a00dd4318c553261a71f7667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a8afffd600bbbea21b4cdc35180e0ded3">QueryInterfaceSharedPtr</a> () const</td></tr>
<tr class="memdesc:a8afffd600bbbea21b4cdc35180e0ded3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr&lt;Interface&gt;()</a>, but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a> to a const-qualified Interface.  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a8afffd600bbbea21b4cdc35180e0ded3">More...</a><br /></td></tr>
<tr class="separator:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a8afffd600bbbea21b4cdc35180e0ded3">QueryInterfaceSharedPtr</a> () const</td></tr>
<tr class="separator:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgz_1_1plugin_1_1Plugin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgz_1_1plugin_1_1Plugin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a></td></tr>
<tr class="memitem:a96cbafa7a127c08d0b97e147f129f5a7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#a96cbafa7a127c08d0b97e147f129f5a7">~Plugin</a> ()</td></tr>
<tr class="memdesc:a96cbafa7a127c08d0b97e147f129f5a7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="classgz_1_1plugin_1_1Plugin.html#a96cbafa7a127c08d0b97e147f129f5a7">More...</a><br /></td></tr>
<tr class="separator:a96cbafa7a127c08d0b97e147f129f5a7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> () const</td></tr>
<tr class="memdesc:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface.  <a href="classgz_1_1plugin_1_1Plugin.html#af00a56f400aaf960349d00e50d8effd5">More...</a><br /></td></tr>
<tr class="separator:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024cf112587cb3f084508c8bc6ea1bc7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#a024cf112587cb3f084508c8bc6ea1bc7">HasInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName, const bool _demangled=true) const</td></tr>
<tr class="memdesc:a024cf112587cb3f084508c8bc6ea1bc7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface.  <a href="classgz_1_1plugin_1_1Plugin.html#a024cf112587cb3f084508c8bc6ea1bc7">More...</a><br /></td></tr>
<tr class="separator:a024cf112587cb3f084508c8bc6ea1bc7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfc8b23d97121a3b9ecfdacea8befc7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#accfc8b23d97121a3b9ecfdacea8befc7">Name</a> () const</td></tr>
<tr class="memdesc:accfc8b23d97121a3b9ecfdacea8befc7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a>.  <a href="classgz_1_1plugin_1_1Plugin.html#accfc8b23d97121a3b9ecfdacea8befc7">More...</a><br /></td></tr>
<tr class="separator:accfc8b23d97121a3b9ecfdacea8befc7 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface</a> ()</td></tr>
<tr class="memdesc:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interface of the specified type, if it is provided by this plugin.  <a href="classgz_1_1plugin_1_1Plugin.html#aa5a5071a558207e3853ee0de5f5bcf66">More...</a><br /></td></tr>
<tr class="separator:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#aed5dc9dd27c987508c981e6758901977">QueryInterface</a> () const</td></tr>
<tr class="memdesc:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-qualified version of <a class="el" href="classgz_1_1plugin_1_1Plugin.html#aa5a5071a558207e3853ee0de5f5bcf66" title="Get an interface of the specified type, if it is provided by this plugin.">QueryInterface&lt;Interface&gt;()</a>  <a href="classgz_1_1plugin_1_1Plugin.html#aed5dc9dd27c987508c981e6758901977">More...</a><br /></td></tr>
<tr class="separator:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr</a> ()</td></tr>
<tr class="memdesc:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined.  <a href="classgz_1_1plugin_1_1Plugin.html#a2d7fa223a00dd4318c553261a71f7667">More...</a><br /></td></tr>
<tr class="separator:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#a8afffd600bbbea21b4cdc35180e0ded3">QueryInterfaceSharedPtr</a> () const</td></tr>
<tr class="memdesc:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classgz_1_1plugin_1_1Plugin.html#a2d7fa223a00dd4318c553261a71f7667" title="Get the requested interface as a std::shared_ptr. The template argument Interface must exactly match ...">QueryInterfaceSharedPtr&lt;Interface&gt;()</a>, but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a> to a const-qualified Interface.  <a href="classgz_1_1plugin_1_1Plugin.html#a8afffd600bbbea21b4cdc35180e0ded3">More...</a><br /></td></tr>
<tr class="separator:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a44da40bda2e7f751c00ad6b92472cb3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a44da40bda2e7f751c00ad6b92472cb3d">SpecializedPlugin</a> ()</td></tr>
<tr class="memdesc:a44da40bda2e7f751c00ad6b92472cb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a44da40bda2e7f751c00ad6b92472cb3d">More...</a><br /></td></tr>
<tr class="separator:a44da40bda2e7f751c00ad6b92472cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classgz_1_1plugin_1_1Plugin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classgz_1_1plugin_1_1Plugin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a></td></tr>
<tr class="memitem:ac6f2688af203e5a5aa47ec9cea5fb6f2 inherit pro_methods_classgz_1_1plugin_1_1Plugin"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#ac6f2688af203e5a5aa47ec9cea5fb6f2">Plugin</a> ()</td></tr>
<tr class="memdesc:ac6f2688af203e5a5aa47ec9cea5fb6f2 inherit pro_methods_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. This is kept protected to discourage users from instantiating them directly. They should instead only be retrieved as a PluginPtr from the plugin <a class="el" href="classgz_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a>.  <a href="classgz_1_1plugin_1_1Plugin.html#ac6f2688af203e5a5aa47ec9cea5fb6f2">More...</a><br /></td></tr>
<tr class="separator:ac6f2688af203e5a5aa47ec9cea5fb6f2 inherit pro_methods_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classgz_1_1plugin_1_1Plugin"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classgz_1_1plugin_1_1Plugin')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a></td></tr>
<tr class="memitem:ad29972cd94d07457a34e116440b6a7fd inherit pub_types_classgz_1_1plugin_1_1Plugin"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html#ad29972cd94d07457a34e116440b6a7fd">InterfaceMap</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, void * &gt;</td></tr>
<tr class="memdesc:ad29972cd94d07457a34e116440b6a7fd inherit pub_types_classgz_1_1plugin_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">The InterfaceMap type needs to get used in several places, like Plugin::Implementation and SpecializedPlugin&lt;T&gt;. We make the typedef public so that those other classes can use it without needing to be friends of <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a>. End-users should not have any need for this typedef.  <a href="classgz_1_1plugin_1_1Plugin.html#ad29972cd94d07457a34e116440b6a7fd">More...</a><br /></td></tr>
<tr class="separator:ad29972cd94d07457a34e116440b6a7fd inherit pub_types_classgz_1_1plugin_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SpecInterface&gt;<br />
class gz::plugin::SpecializedPlugin&lt; SpecInterface &gt;</h3>

<p>This class allows <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> instances to have high-speed access to interfaces that can be anticipated at compile time. The plugin does not have to actually offer the specialized interface in order to get this performance improvement. This template is variadic, so it can support arbitrarily many interfaces. </p>
<p>Usage example:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> MySpecialPluginPtr = <a class="code" href="namespacegz_1_1plugin.html#a71ecee778dbdcaee4977cedd7341ef55" title="This alias allows PluginPtr instances to have high-speed access to interfaces that can be anticipated...">SpecializedPluginPtr</a>&lt;</div>
<div class="line">    MyInterface1, FooInterface, MyInterface2, BarInterface&gt;;</div>
<div class="line"> </div>
<div class="line">MySpecialPluginPtr plugin = loader-&gt;Instantiate(pluginName);</div>
</div><!-- fragment --><p>Then, calling the function</p>
<div class="fragment"><div class="line">plugin-&gt;QueryInterface&lt;FooInterface&gt;();</div>
</div><!-- fragment --><p>will have extremely high-speed associated with it. It will provide direct access to the the <code>FooInterface*</code> of <code>plugin</code>. If <code>plugin</code> does not actually offer <code>FooInterface</code>, then it will return a nullptr, still at extremely high speed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a44da40bda2e7f751c00ad6b92472cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44da40bda2e7f751c00ad6b92472cb3d">&#9670;&nbsp;</a></span>SpecializedPlugin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin.html">SpecializedPlugin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af00a56f400aaf960349d00e50d8effd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a56f400aaf960349d00e50d8effd5">&#9670;&nbsp;</a></span>HasInterface() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface, and false otherwise. </dd></dl>

</div>
</div>
<a id="af00a56f400aaf960349d00e50d8effd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a56f400aaf960349d00e50d8effd5">&#9670;&nbsp;</a></span>HasInterface() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a024cf112587cb3f084508c8bc6ea1bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024cf112587cb3f084508c8bc6ea1bc7">&#9670;&nbsp;</a></span>HasInterface() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInterface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface. </p>
<p>By default, we expect you to pass in a demangled version of the interface name. If you want to use a mangled version of the name, set the <code>demangled</code> argument to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_interfaceName</td><td>The name of the desired interface, as a <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>. Note that this expects the name to be mangled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_demangled</td><td>If _interfaceName is demangled, set this to true. If you are instead using the raw mangled name that gets provided by typeid(T).name(), then set _demangled to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> has the specified type of interface, and false otherwise. </dd></dl>

</div>
</div>
<a id="aa5a5071a558207e3853ee0de5f5bcf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a5071a558207e3853ee0de5f5bcf66">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an interface of the specified type, if it is provided by this plugin. </p>
<p>Note that the interface pointer you receive is owned by the <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> object. You MUST NOT ever try to deallocate it yourself. Moreover, the pointer will be invalidated once all <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> objects that refer to the same <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> instance are destructed. Use the QueryInterfaceSharedPtr function in order to get a reference-counting pointer to an interface of this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> object. The pointer will remain valid as long as the <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a> provided by QueryInterfaceSharedPtr is alive.</p>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to the specified interface. If the requested _interfaceName is not provided by this <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a>, this returns a nullptr. This pointer is invalidated when the reference count of the plugin instance drops to zero. </dd></dl>

</div>
</div>
<a id="aa5a5071a558207e3853ee0de5f5bcf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a5071a558207e3853ee0de5f5bcf66">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed5dc9dd27c987508c981e6758901977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5dc9dd27c987508c981e6758901977">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const-qualified version of <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface&lt;Interface&gt;()</a> </p>

</div>
</div>
<a id="aed5dc9dd27c987508c981e6758901977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5dc9dd27c987508c981e6758901977">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d7fa223a00dd4318c553261a71f7667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7fa223a00dd4318c553261a71f7667">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined. </p>
<p>This <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a> and the interface+plugin that it refers to will remain valid, even if all <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> objects which refer to the plugin instance are destructed.</p>
<p>You MUST NOT attempt to pass a QueryInterface pointer into a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a> yourself; that will result in double-delete memory errors. You must always call QueryInterfaceSharedPtr for a reference- counting pointer to an interface.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference-counting pointer to the specified interface. This will keep the interface valid and the plugin instance alive, even if all <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> objects that refer to this plugin instance are destructed. </dd></dl>

</div>
</div>
<a id="a2d7fa223a00dd4318c553261a71f7667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7fa223a00dd4318c553261a71f7667">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8afffd600bbbea21b4cdc35180e0ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afffd600bbbea21b4cdc35180e0ded3">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;const Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr&lt;Interface&gt;()</a>, but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a> to a const-qualified Interface. </p>

</div>
</div>
<a id="a8afffd600bbbea21b4cdc35180e0ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afffd600bbbea21b4cdc35180e0ded3">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;const Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gz_2plugin_2SpecializedPlugin_8hh_source.html">gz/plugin/SpecializedPlugin.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
