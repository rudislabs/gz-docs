<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Math">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Math: Graph&lt; V, E, EdgeType &gt; Class Template Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Math</h1>
        <h2>API Reference</h2>
        <div class="version">
        7.5.1
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1math.html">math</a></li><li class="navelem"><a class="el" href="namespacegz_1_1math_1_1graph.html">graph</a></li><li class="navelem"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgz_1_1math_1_1graph_1_1Graph-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Graph&lt; V, E, EdgeType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic graph class. Both vertices and edges can store user information. A vertex could be created passing a custom Id if needed, otherwise it will be choosen internally. The vertices also have a name that could be reused among other vertices if needed. This class supports the use of different edge types (e.g. directed or undirected edges).  
 <a href="classgz_1_1math_1_1graph_1_1Graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gz_2math_2graph_2Graph_8hh_source.html">Graph.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c40af42cad207665228815f0359bbd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a0c40af42cad207665228815f0359bbd3">Graph</a> ()=default</td></tr>
<tr class="memdesc:a0c40af42cad207665228815f0359bbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a0c40af42cad207665228815f0359bbd3">More...</a><br /></td></tr>
<tr class="separator:a0c40af42cad207665228815f0359bbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af324bc33f5bb44a19a1e1d2ca2af7ed2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#af324bc33f5bb44a19a1e1d2ca2af7ed2">Graph</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt;&gt; &amp;_vertices, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structgz_1_1math_1_1graph_1_1EdgeInitializer.html">EdgeInitializer</a>&lt; E &gt;&gt; &amp;_edges)</td></tr>
<tr class="memdesc:af324bc33f5bb44a19a1e1d2ca2af7ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#af324bc33f5bb44a19a1e1d2ca2af7ed2">More...</a><br /></td></tr>
<tr class="separator:af324bc33f5bb44a19a1e1d2ca2af7ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bf01a9bf40ee27f08405b404187235"><td class="memItemLeft" align="right" valign="top">EdgeType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a41bf01a9bf40ee27f08405b404187235">AddEdge</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a88dc10e7b6811e71d1132c875014c18c">VertexId_P</a> &amp;_vertices, const E &amp;_data, const double _weight=1.0)</td></tr>
<tr class="memdesc:a41bf01a9bf40ee27f08405b404187235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new edge to the graph.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a41bf01a9bf40ee27f08405b404187235">More...</a><br /></td></tr>
<tr class="separator:a41bf01a9bf40ee27f08405b404187235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d827829d28146a07586160b8addaccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a0d827829d28146a07586160b8addaccf">AddVertex</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name, const V &amp;_data, const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_id=<a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">kNullId</a>)</td></tr>
<tr class="memdesc:a0d827829d28146a07586160b8addaccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new vertex to the graph.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a0d827829d28146a07586160b8addaccf">More...</a><br /></td></tr>
<tr class="separator:a0d827829d28146a07586160b8addaccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af840ae4a776fa7d1f3003c2400e7a358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#af840ae4a776fa7d1f3003c2400e7a358">AdjacentsFrom</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;_vertex) const</td></tr>
<tr class="memdesc:af840ae4a776fa7d1f3003c2400e7a358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all vertices that are directly connected with one edge from a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex). E.g. j is adjacent from i (the given vertex) if there is an edge (i-&gt;j).  <a href="classgz_1_1math_1_1graph_1_1Graph.html#af840ae4a776fa7d1f3003c2400e7a358">More...</a><br /></td></tr>
<tr class="separator:af840ae4a776fa7d1f3003c2400e7a358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2df28d5a426724e36fde045a2398bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">AdjacentsFrom</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_vertex) const</td></tr>
<tr class="memdesc:a1b2df28d5a426724e36fde045a2398bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all vertices that are directly connected with one edge from a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex). E.g. j is adjacent from i (the given vertex) if there is an edge (i-&gt;j).  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">More...</a><br /></td></tr>
<tr class="separator:a1b2df28d5a426724e36fde045a2398bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45a5fed211840bfbb142838834bd975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#af45a5fed211840bfbb142838834bd975">AdjacentsTo</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;_vertex) const</td></tr>
<tr class="memdesc:af45a5fed211840bfbb142838834bd975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all vertices that are directly connected with one edge to a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex).  <a href="classgz_1_1math_1_1graph_1_1Graph.html#af45a5fed211840bfbb142838834bd975">More...</a><br /></td></tr>
<tr class="separator:af45a5fed211840bfbb142838834bd975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c3c5d658e6e209bd2df3ba9816488d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ac5c3c5d658e6e209bd2df3ba9816488d">AdjacentsTo</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_vertex) const</td></tr>
<tr class="memdesc:ac5c3c5d658e6e209bd2df3ba9816488d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all vertices that are directly connected with one edge to a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex).  <a href="classgz_1_1math_1_1graph_1_1Graph.html#ac5c3c5d658e6e209bd2df3ba9816488d">More...</a><br /></td></tr>
<tr class="separator:ac5c3c5d658e6e209bd2df3ba9816488d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba06ce47e09eccad6f905387ee2f719"><td class="memItemLeft" align="right" valign="top">EdgeType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#adba06ce47e09eccad6f905387ee2f719">EdgeFromId</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> &amp;_id)</td></tr>
<tr class="memdesc:adba06ce47e09eccad6f905387ee2f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to an edge using its Id.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#adba06ce47e09eccad6f905387ee2f719">More...</a><br /></td></tr>
<tr class="separator:adba06ce47e09eccad6f905387ee2f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e9d57290d978aeef111417f37ada36"><td class="memItemLeft" align="right" valign="top">const EdgeType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56e9d57290d978aeef111417f37ada36">EdgeFromId</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> &amp;_id) const</td></tr>
<tr class="memdesc:a56e9d57290d978aeef111417f37ada36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an edge using its Id.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a56e9d57290d978aeef111417f37ada36">More...</a><br /></td></tr>
<tr class="separator:a56e9d57290d978aeef111417f37ada36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec812f5facd444680da38d12a42f888"><td class="memItemLeft" align="right" valign="top">const EdgeType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a2ec812f5facd444680da38d12a42f888">EdgeFromVertices</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> _sourceId, const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> _destId) const</td></tr>
<tr class="memdesc:a2ec812f5facd444680da38d12a42f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an edge based on two vertices. A NullEdge object reference is returned if an edge with the two vertices is not found. If there are multiple edges that match the provided vertices, then first is returned.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a2ec812f5facd444680da38d12a42f888">More...</a><br /></td></tr>
<tr class="separator:a2ec812f5facd444680da38d12a42f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c98ee28ae312d26adb03cd9b12363f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt; EdgeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a80c98ee28ae312d26adb03cd9b12363f">Edges</a> () const</td></tr>
<tr class="memdesc:a80c98ee28ae312d26adb03cd9b12363f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of all edges in the graph.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a80c98ee28ae312d26adb03cd9b12363f">More...</a><br /></td></tr>
<tr class="separator:a80c98ee28ae312d26adb03cd9b12363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbdba215d3b15fbb4b682969943a6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abcfbdba215d3b15fbb4b682969943a6e">Empty</a> () const</td></tr>
<tr class="memdesc:abcfbdba215d3b15fbb4b682969943a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the graph is empty.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#abcfbdba215d3b15fbb4b682969943a6e">More...</a><br /></td></tr>
<tr class="separator:abcfbdba215d3b15fbb4b682969943a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5d1327b7ab01356e502b465d5109b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt; EdgeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a6e5d1327b7ab01356e502b465d5109b2">IncidentsFrom</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;_vertex) const</td></tr>
<tr class="memdesc:a6e5d1327b7ab01356e502b465d5109b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of outgoing edges from a given vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a6e5d1327b7ab01356e502b465d5109b2">More...</a><br /></td></tr>
<tr class="separator:a6e5d1327b7ab01356e502b465d5109b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75226801052d910550bb03bce6df8ab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt; EdgeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">IncidentsFrom</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_vertex) const</td></tr>
<tr class="memdesc:a75226801052d910550bb03bce6df8ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of outgoing edges from a given vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">More...</a><br /></td></tr>
<tr class="separator:a75226801052d910550bb03bce6df8ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e91f83e82f1187748f00c6f8cfed61f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt; EdgeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a6e91f83e82f1187748f00c6f8cfed61f">IncidentsTo</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;_vertex) const</td></tr>
<tr class="memdesc:a6e91f83e82f1187748f00c6f8cfed61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of incoming edges to a given vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a6e91f83e82f1187748f00c6f8cfed61f">More...</a><br /></td></tr>
<tr class="separator:a6e91f83e82f1187748f00c6f8cfed61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd602eb002d37ae71e0b00d8ece51bc5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt; EdgeType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">IncidentsTo</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_vertex) const</td></tr>
<tr class="memdesc:abd602eb002d37ae71e0b00d8ece51bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of incoming edges to a given vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">More...</a><br /></td></tr>
<tr class="separator:abd602eb002d37ae71e0b00d8ece51bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0acb17e8c591dea2a66ff7693fcc17"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a6b0acb17e8c591dea2a66ff7693fcc17">InDegree</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;_vertex) const</td></tr>
<tr class="memdesc:a6b0acb17e8c591dea2a66ff7693fcc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges incident to a vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a6b0acb17e8c591dea2a66ff7693fcc17">More...</a><br /></td></tr>
<tr class="separator:a6b0acb17e8c591dea2a66ff7693fcc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda5e2df63fe6ddc5be304b10836205d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#adda5e2df63fe6ddc5be304b10836205d">InDegree</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_vertex) const</td></tr>
<tr class="memdesc:adda5e2df63fe6ddc5be304b10836205d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges incident to a vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#adda5e2df63fe6ddc5be304b10836205d">More...</a><br /></td></tr>
<tr class="separator:adda5e2df63fe6ddc5be304b10836205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d8b54b2405f303d7b6f91879da183f"><td class="memItemLeft" align="right" valign="top">EdgeType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ae5d8b54b2405f303d7b6f91879da183f">LinkEdge</a> (const EdgeType &amp;_edge)</td></tr>
<tr class="memdesc:ae5d8b54b2405f303d7b6f91879da183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links an edge to the graph. This function verifies that the edge's two vertices exist in the graph, copies the edge into the graph's internal data structure, and returns a reference to this new edge.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#ae5d8b54b2405f303d7b6f91879da183f">More...</a><br /></td></tr>
<tr class="separator:ae5d8b54b2405f303d7b6f91879da183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fd44a4e2a43ed903ea48ae9734c8b0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a13fd44a4e2a43ed903ea48ae9734c8b0">OutDegree</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;_vertex) const</td></tr>
<tr class="memdesc:a13fd44a4e2a43ed903ea48ae9734c8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges incident from a vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a13fd44a4e2a43ed903ea48ae9734c8b0">More...</a><br /></td></tr>
<tr class="separator:a13fd44a4e2a43ed903ea48ae9734c8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f7986cba7b23aa47a5d885547f67bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a40f7986cba7b23aa47a5d885547f67bd">OutDegree</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_vertex) const</td></tr>
<tr class="memdesc:a40f7986cba7b23aa47a5d885547f67bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges incident from a vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a40f7986cba7b23aa47a5d885547f67bd">More...</a><br /></td></tr>
<tr class="separator:a40f7986cba7b23aa47a5d885547f67bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acded76285173462d9292a6e716854b26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#acded76285173462d9292a6e716854b26">RemoveEdge</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> &amp;_edge)</td></tr>
<tr class="memdesc:acded76285173462d9292a6e716854b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an existing edge from the graph. After the removal, it won't be possible to reach any of the vertices from the edge, unless there are other edges that connect the to vertices.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#acded76285173462d9292a6e716854b26">More...</a><br /></td></tr>
<tr class="separator:acded76285173462d9292a6e716854b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68247a4c93cc34ce189e8bed2aac6886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a68247a4c93cc34ce189e8bed2aac6886">RemoveEdge</a> (EdgeType &amp;_edge)</td></tr>
<tr class="memdesc:a68247a4c93cc34ce189e8bed2aac6886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an existing edge from the graph. After the removal, it won't be possible to reach any of the vertices from the edge, unless there are other edges that connect the to vertices.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a68247a4c93cc34ce189e8bed2aac6886">More...</a><br /></td></tr>
<tr class="separator:a68247a4c93cc34ce189e8bed2aac6886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fc2c300e17bb107b5118182dfb0099"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56fc2c300e17bb107b5118182dfb0099">RemoveVertex</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_vertex)</td></tr>
<tr class="memdesc:a56fc2c300e17bb107b5118182dfb0099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an existing vertex from the graph.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a56fc2c300e17bb107b5118182dfb0099">More...</a><br /></td></tr>
<tr class="separator:a56fc2c300e17bb107b5118182dfb0099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1389cc1b2e80b835230deb2f0a9816a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1389cc1b2e80b835230deb2f0a9816a4">RemoveVertex</a> (<a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;_vertex)</td></tr>
<tr class="memdesc:a1389cc1b2e80b835230deb2f0a9816a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an existing vertex from the graph.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a1389cc1b2e80b835230deb2f0a9816a4">More...</a><br /></td></tr>
<tr class="separator:a1389cc1b2e80b835230deb2f0a9816a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababc7a882b46052d6e93f235f4cd6f19"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ababc7a882b46052d6e93f235f4cd6f19">RemoveVertices</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)</td></tr>
<tr class="memdesc:ababc7a882b46052d6e93f235f4cd6f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vertices with name == _name.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#ababc7a882b46052d6e93f235f4cd6f19">More...</a><br /></td></tr>
<tr class="separator:ababc7a882b46052d6e93f235f4cd6f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ee1f29a7476ea70ed6e1f6618b0e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ad6ee1f29a7476ea70ed6e1f6618b0e42">VertexFromId</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_id)</td></tr>
<tr class="memdesc:ad6ee1f29a7476ea70ed6e1f6618b0e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to a vertex using its Id.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#ad6ee1f29a7476ea70ed6e1f6618b0e42">More...</a><br /></td></tr>
<tr class="separator:ad6ee1f29a7476ea70ed6e1f6618b0e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3424c0c193ab38d9f6cf7582a2fa0830"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">VertexFromId</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_id) const</td></tr>
<tr class="memdesc:a3424c0c193ab38d9f6cf7582a2fa0830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a vertex using its Id.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">More...</a><br /></td></tr>
<tr class="separator:a3424c0c193ab38d9f6cf7582a2fa0830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1d28212e2e3170856ef2c86f29c4a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a9e1d28212e2e3170856ef2c86f29c4a6">Vertices</a> () const</td></tr>
<tr class="memdesc:a9e1d28212e2e3170856ef2c86f29c4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of all vertices in the graph.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a9e1d28212e2e3170856ef2c86f29c4a6">More...</a><br /></td></tr>
<tr class="separator:a9e1d28212e2e3170856ef2c86f29c4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae1438d54d40ebc4df80206988bbfd7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a5ae1438d54d40ebc4df80206988bbfd7">Vertices</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const</td></tr>
<tr class="memdesc:a5ae1438d54d40ebc4df80206988bbfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of all vertices in the graph with name == _name.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a5ae1438d54d40ebc4df80206988bbfd7">More...</a><br /></td></tr>
<tr class="separator:a5ae1438d54d40ebc4df80206988bbfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2b6dc168e5adcb5cb871cf23de252f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a2b6dc168e5adcb5cb871cf23de252f18">nextEdgeId</a> = 0u</td></tr>
<tr class="memdesc:a2b6dc168e5adcb5cb871cf23de252f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next edge Id to be assigned to a new edge.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a2b6dc168e5adcb5cb871cf23de252f18">More...</a><br /></td></tr>
<tr class="separator:a2b6dc168e5adcb5cb871cf23de252f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0248262f6eabac11826e847018ac3ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a0248262f6eabac11826e847018ac3ebb">nextVertexId</a> = 0u</td></tr>
<tr class="memdesc:a0248262f6eabac11826e847018ac3ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next vertex Id to be assigned to a new vertex.  <a href="classgz_1_1math_1_1graph_1_1Graph.html#a0248262f6eabac11826e847018ac3ebb">More...</a><br /></td></tr>
<tr class="separator:a0248262f6eabac11826e847018ac3ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename V, typename E, typename EdgeType&gt;<br />
class gz::math::graph::Graph&lt; V, E, EdgeType &gt;</h3>

<p>A generic graph class. Both vertices and edges can store user information. A vertex could be created passing a custom Id if needed, otherwise it will be choosen internally. The vertices also have a name that could be reused among other vertices if needed. This class supports the use of different edge types (e.g. directed or undirected edges). </p>
<p><b> Example directed graph</b> </p><div class="fragment"><div class="line"><span class="comment">// Create a directed graph that is capable of storing integer data in the</span></div>
<div class="line"><span class="comment">// vertices and double data on the edges.</span></div>
<div class="line">graph::DirectedGraph&lt;int, double&gt; graph(</div>
<div class="line">  <span class="comment">// Create the vertices, with default data and vertex ids.</span></div>
<div class="line">  {</div>
<div class="line">    {<span class="stringliteral">&quot;vertex1&quot;</span>}, {<span class="stringliteral">&quot;vertex2&quot;</span>}, {<span class="stringliteral">&quot;vertex3&quot;</span>}</div>
<div class="line">  },</div>
<div class="line">  <span class="comment">// Create the edges, with default data and weight values.</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Edge from vertex 0 to vertex 1. Each number refers to a vertex id.</span></div>
<div class="line">    <span class="comment">// Vertex ids start from zero.</span></div>
<div class="line">    {{0, 1}}, {{1, 2}}</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can assign data to vertices.</span></div>
<div class="line">graph::DirectedGraph&lt;int, double&gt; graph2(</div>
<div class="line">  <span class="comment">// Create the vertices, with custom data and default vertex ids.</span></div>
<div class="line">  {</div>
<div class="line">    {<span class="stringliteral">&quot;vertex1&quot;</span>, 1}, {<span class="stringliteral">&quot;vertex2&quot;</span>, 2}, {<span class="stringliteral">&quot;vertex3&quot;</span>, 10}</div>
<div class="line">  },</div>
<div class="line">  <span class="comment">// Create the edges, with default data and weight values.</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Edge from vertex 0 to vertex 1. Each number refers to a vertex id</span></div>
<div class="line">    <span class="comment">// specified above.</span></div>
<div class="line">    {{0, 2}}, {{1, 2}}</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// It&#39;s also possible to specify vertex ids.</span></div>
<div class="line">graph::DirectedGraph&lt;int, double&gt; graph3(</div>
<div class="line">  <span class="comment">// Create the vertices with custom data and vertex ids.</span></div>
<div class="line">  {</div>
<div class="line">    {<span class="stringliteral">&quot;vertex1&quot;</span>, 1, 2}, {<span class="stringliteral">&quot;vertex2&quot;</span>, 2, 3}, {<span class="stringliteral">&quot;vertex3&quot;</span>, 10, 4}</div>
<div class="line">  },</div>
<div class="line">  <span class="comment">// Create the edges, with custom data and default weight values.</span></div>
<div class="line">  {</div>
<div class="line">    {{2, 3}, 6.3}, {{3, 4}, 4.2}</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Finally, you can also assign weights to the edges.</span></div>
<div class="line">graph::DirectedGraph&lt;int, double&gt; graph4(</div>
<div class="line">  <span class="comment">// Create the vertices with custom data and vertex ids.</span></div>
<div class="line">  {</div>
<div class="line">    {<span class="stringliteral">&quot;vertex1&quot;</span>, 1, 2}, {<span class="stringliteral">&quot;vertex2&quot;</span>, 2, 3}, {<span class="stringliteral">&quot;vertex3&quot;</span>, 10, 4}</div>
<div class="line">  },</div>
<div class="line">  <span class="comment">// Create the edges, with custom data and default weight values</span></div>
<div class="line">  {</div>
<div class="line">    {{2, 3}, 6.3, 1.1}, {{3, 4}, 4.2, 2.3}</div>
<div class="line">  });</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c40af42cad207665228815f0359bbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c40af42cad207665228815f0359bbd3">&#9670;&nbsp;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="af324bc33f5bb44a19a1e1d2ca2af7ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af324bc33f5bb44a19a1e1d2ca2af7ed2">&#9670;&nbsp;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structgz_1_1math_1_1graph_1_1EdgeInitializer.html">EdgeInitializer</a>&lt; E &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertices</td><td>Collection of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_edges</td><td>Collection of edges. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a41bf01a9bf40ee27f08405b404187235">Graph&lt; V, E, EdgeType &gt;::AddEdge()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a0d827829d28146a07586160b8addaccf">Graph&lt; V, E, EdgeType &gt;::AddVertex()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a41bf01a9bf40ee27f08405b404187235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bf01a9bf40ee27f08405b404187235">&#9670;&nbsp;</a></span>AddEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType&amp; AddEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a88dc10e7b6811e71d1132c875014c18c">VertexId_P</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_weight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertices</td><td>The set of Ids of the two vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_data</td><td>User data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_weight</td><td><a class="el" href="classgz_1_1math_1_1graph_1_1Edge.html" title="Generic edge class. An edge has two ends and some constraint between them. For example,...">Edge</a> weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the new edge created or NullEdge if the edge was not created (e.g. incorrect vertices). </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">gz::math::graph::kNullId</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ae5d8b54b2405f303d7b6f91879da183f">Graph&lt; V, E, EdgeType &gt;::LinkEdge()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#af324bc33f5bb44a19a1e1d2ca2af7ed2">Graph&lt; V, E, EdgeType &gt;::Graph()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">gz::math::graph::BreadthFirstSort()</a>, and <a class="el" href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">gz::math::graph::DepthFirstSort()</a>.</p>

</div>
</div>
<a id="a0d827829d28146a07586160b8addaccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d827829d28146a07586160b8addaccf">&#9670;&nbsp;</a></span>AddVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt;V&gt;&amp; AddVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_id</em> = <code><a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">kNullId</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new vertex to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the vertex. It doesn't have to be unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_data</td><td>Data to be stored in the vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>Optional Id to be used for this vertex. This Id must be unique. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new vertex. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/multimap/insert.html">multimap&lt; K, T &gt;::insert()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">gz::math::graph::kNullId</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#af324bc33f5bb44a19a1e1d2ca2af7ed2">Graph&lt; V, E, EdgeType &gt;::Graph()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">gz::math::graph::BreadthFirstSort()</a>, and <a class="el" href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">gz::math::graph::DepthFirstSort()</a>.</p>

</div>
</div>
<a id="af840ae4a776fa7d1f3003c2400e7a358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af840ae4a776fa7d1f3003c2400e7a358">&#9670;&nbsp;</a></span>AdjacentsFrom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt;V&gt; AdjacentsFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all vertices that are directly connected with one edge from a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex). E.g. j is adjacent from i (the given vertex) if there is an edge (i-&gt;j). </p>
<p>In an undirected graph, the result of this function will match the result provided by AdjacentsTo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The Id of the vertex from which adjacent vertices will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of vertices, where keys are Ids and values are references to the vertices. This is the set of adjacent vertices. An empty map will be returned when the _vertex is not found in the graph. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">Graph&lt; V, E, EdgeType &gt;::AdjacentsFrom()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#aa499ff4aa3cc5447d55b1942e14815af">Vertex&lt; V &gt;::Id()</a>.</p>

</div>
</div>
<a id="a1b2df28d5a426724e36fde045a2398bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2df28d5a426724e36fde045a2398bf">&#9670;&nbsp;</a></span>AdjacentsFrom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt;V&gt; AdjacentsFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all vertices that are directly connected with one edge from a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex). E.g. j is adjacent from i (the given vertex) if there is an edge (i-&gt;j). </p>
<p>In an undirected graph, the result of this function will match the result provided by AdjacentsTo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The Id of the vertex from which adjacent vertices will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of vertices, where keys are Ids and values are references to the vertices. This is the set of adjacent vertices. An empty map will be returned when the _vertex is not found in the graph. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/ref.html">std::cref()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56e9d57290d978aeef111417f37ada36">Graph&lt; V, E, EdgeType &gt;::EdgeFromId()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/emplace.html">map&lt; K, T &gt;::emplace()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">gz::math::graph::kNullId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">Graph&lt; V, E, EdgeType &gt;::VertexFromId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#af840ae4a776fa7d1f3003c2400e7a358">Graph&lt; V, E, EdgeType &gt;::AdjacentsFrom()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">gz::math::graph::BreadthFirstSort()</a>, and <a class="el" href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">gz::math::graph::DepthFirstSort()</a>.</p>

</div>
</div>
<a id="af45a5fed211840bfbb142838834bd975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45a5fed211840bfbb142838834bd975">&#9670;&nbsp;</a></span>AdjacentsTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt;V&gt; AdjacentsTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all vertices that are directly connected with one edge to a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex). </p>
<p>In an undirected graph, the result of this function will match the result provided by AdjacentsFrom.</p>
<p>E.g. i is adjacent to j (the given vertex) if there is an edge (i-&gt;j). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex to check adjacentsTo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of vertices, where keys are Ids and values are references to the vertices. An empty map is returned if the _vertex is not present in this graph, or when there are no adjacent vertices. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ac5c3c5d658e6e209bd2df3ba9816488d">Graph&lt; V, E, EdgeType &gt;::AdjacentsTo()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#aa499ff4aa3cc5447d55b1942e14815af">Vertex&lt; V &gt;::Id()</a>.</p>

</div>
</div>
<a id="ac5c3c5d658e6e209bd2df3ba9816488d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c3c5d658e6e209bd2df3ba9816488d">&#9670;&nbsp;</a></span>AdjacentsTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt;V&gt; AdjacentsTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all vertices that are directly connected with one edge to a given vertex. In other words, this function will return child vertices of the given vertex (all vertices from the given vertex). </p>
<p>In an undirected graph, the result of this function will match the result provided by AdjacentsFrom.</p>
<p>E.g. i is adjacent to j (the given vertex) if there is an edge (i-&gt;j). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The Id of the vertex to check adjacentsTo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of vertices, where keys are Ids and values are references to the vertices. An empty map is returned if the _vertex is not present in this graph, or when there are no adjacent vertices. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/ref.html">std::cref()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56e9d57290d978aeef111417f37ada36">Graph&lt; V, E, EdgeType &gt;::EdgeFromId()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/emplace.html">map&lt; K, T &gt;::emplace()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">Graph&lt; V, E, EdgeType &gt;::VertexFromId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#af45a5fed211840bfbb142838834bd975">Graph&lt; V, E, EdgeType &gt;::AdjacentsTo()</a>.</p>

</div>
</div>
<a id="adba06ce47e09eccad6f905387ee2f719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba06ce47e09eccad6f905387ee2f719">&#9670;&nbsp;</a></span>EdgeFromId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType&amp; EdgeFromId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> &amp;&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mutable reference to an edge uusing its Id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>The Id of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable reference to the edge with Id = _id or NullEdge if not found. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/end.html">map&lt; K, T &gt;::end()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/find.html">map&lt; K, T &gt;::find()</a>.</p>

</div>
</div>
<a id="a56e9d57290d978aeef111417f37ada36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e9d57290d978aeef111417f37ada36">&#9670;&nbsp;</a></span>EdgeFromId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EdgeType&amp; EdgeFromId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> &amp;&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to an edge using its Id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>The Id of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the edge with Id = _id or NullEdge if not found. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/end.html">map&lt; K, T &gt;::end()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/find.html">map&lt; K, T &gt;::find()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">Graph&lt; V, E, EdgeType &gt;::AdjacentsFrom()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ac5c3c5d658e6e209bd2df3ba9816488d">Graph&lt; V, E, EdgeType &gt;::AdjacentsTo()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>.</p>

</div>
</div>
<a id="a2ec812f5facd444680da38d12a42f888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec812f5facd444680da38d12a42f888">&#9670;&nbsp;</a></span>EdgeFromVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EdgeType&amp; EdgeFromVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&#160;</td>
          <td class="paramname"><em>_sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&#160;</td>
          <td class="paramname"><em>_destId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to an edge based on two vertices. A NullEdge object reference is returned if an edge with the two vertices is not found. If there are multiple edges that match the provided vertices, then first is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_sourceId</td><td>Source vertex Id. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_destId</td><td>Destination vertex Id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first edge found, or NullEdge if not found. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/begin.html">map&lt; K, T &gt;::begin()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/end.html">map&lt; K, T &gt;::end()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/find.html">map&lt; K, T &gt;::find()</a>.</p>

</div>
</div>
<a id="a80c98ee28ae312d26adb03cd9b12363f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c98ee28ae312d26adb03cd9b12363f">&#9670;&nbsp;</a></span>Edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt;EdgeType&gt; Edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collection of all edges in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A map of edges, where keys are Ids and values are references to the edges. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/ref.html">std::cref()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/emplace.html">map&lt; K, T &gt;::emplace()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">gz::math::graph::BreadthFirstSort()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a61a448fd0197b5e39056c6178a613619">gz::math::graph::ConnectedComponents()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">gz::math::graph::DepthFirstSort()</a>, and <a class="el" href="namespacegz_1_1math_1_1graph.html#a9f5832ba872b12d625d3b7cd48d8144d">gz::math::graph::ToUndirectedGraph()</a>.</p>

</div>
</div>
<a id="abcfbdba215d3b15fbb4b682969943a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfbdba215d3b15fbb4b682969943a6e">&#9670;&nbsp;</a></span>Empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the graph is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True when there are no vertices in the graph or false otherwise. </dd></dl>

</div>
</div>
<a id="a6e5d1327b7ab01356e502b465d5109b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5d1327b7ab01356e502b465d5109b2">&#9670;&nbsp;</a></span>IncidentsFrom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt;EdgeType&gt; IncidentsFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the set of outgoing edges from a given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of edges, where keys are Ids and values are references to the edges. An empty map is returned when the provided vertex does not exist, or when there are no outgoing edges. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#aa499ff4aa3cc5447d55b1942e14815af">Vertex&lt; V &gt;::Id()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>.</p>

</div>
</div>
<a id="a75226801052d910550bb03bce6df8ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75226801052d910550bb03bce6df8ab6">&#9670;&nbsp;</a></span>IncidentsFrom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt;EdgeType&gt; IncidentsFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the set of outgoing edges from a given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>Id of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of edges, where keys are Ids and values are references to the edges. An empty map is returned when the provided vertex does not exist, or when there are no outgoing edges. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/ref.html">std::cref()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56e9d57290d978aeef111417f37ada36">Graph&lt; V, E, EdgeType &gt;::EdgeFromId()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/emplace.html">map&lt; K, T &gt;::emplace()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">gz::math::graph::kNullId</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegz_1_1math_1_1graph.html#aad10f204b8ee7e8cb0d24b4fa0fa52cb">gz::math::graph::Dijkstra()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a6e5d1327b7ab01356e502b465d5109b2">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a40f7986cba7b23aa47a5d885547f67bd">Graph&lt; V, E, EdgeType &gt;::OutDegree()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56fc2c300e17bb107b5118182dfb0099">Graph&lt; V, E, EdgeType &gt;::RemoveVertex()</a>.</p>

</div>
</div>
<a id="a6e91f83e82f1187748f00c6f8cfed61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e91f83e82f1187748f00c6f8cfed61f">&#9670;&nbsp;</a></span>IncidentsTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt;EdgeType&gt; IncidentsTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the set of incoming edges to a given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of edges, where keys are Ids and values are references to the edges. An empty map is returned when the provided vertex does not exist, or when there are no incoming edges. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#aa499ff4aa3cc5447d55b1942e14815af">Vertex&lt; V &gt;::Id()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>.</p>

</div>
</div>
<a id="abd602eb002d37ae71e0b00d8ece51bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd602eb002d37ae71e0b00d8ece51bc5">&#9670;&nbsp;</a></span>IncidentsTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a>&lt;EdgeType&gt; IncidentsTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the set of incoming edges to a given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>Id of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of edges, where keys are Ids and values are references to the edges. An empty map is returned when the provided vertex does not exist, or when there are no incoming edges. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/ref.html">std::cref()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56e9d57290d978aeef111417f37ada36">Graph&lt; V, E, EdgeType &gt;::EdgeFromId()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/emplace.html">map&lt; K, T &gt;::emplace()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">gz::math::graph::kNullId</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ac5c3c5d658e6e209bd2df3ba9816488d">Graph&lt; V, E, EdgeType &gt;::AdjacentsTo()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a6e91f83e82f1187748f00c6f8cfed61f">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#adda5e2df63fe6ddc5be304b10836205d">Graph&lt; V, E, EdgeType &gt;::InDegree()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56fc2c300e17bb107b5118182dfb0099">Graph&lt; V, E, EdgeType &gt;::RemoveVertex()</a>.</p>

</div>
</div>
<a id="a6b0acb17e8c591dea2a66ff7693fcc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0acb17e8c591dea2a66ff7693fcc17">&#9670;&nbsp;</a></span>InDegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t InDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of edges incident to a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges incidents to a vertex. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#aa499ff4aa3cc5447d55b1942e14815af">Vertex&lt; V &gt;::Id()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">Graph&lt; V, E, EdgeType &gt;::VertexFromId()</a>.</p>

</div>
</div>
<a id="adda5e2df63fe6ddc5be304b10836205d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda5e2df63fe6ddc5be304b10836205d">&#9670;&nbsp;</a></span>InDegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t InDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of edges incident to a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex Id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges incidents to a vertex. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>.</p>

</div>
</div>
<a id="ae5d8b54b2405f303d7b6f91879da183f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d8b54b2405f303d7b6f91879da183f">&#9670;&nbsp;</a></span>LinkEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EdgeType&amp; LinkEdge </td>
          <td>(</td>
          <td class="paramtype">const EdgeType &amp;&#160;</td>
          <td class="paramname"><em>_edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links an edge to the graph. This function verifies that the edge's two vertices exist in the graph, copies the edge into the graph's internal data structure, and returns a reference to this new edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_edge</td><td>An edge to copy into the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new edge. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/insert.html">map&lt; K, T &gt;::insert()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">gz::math::graph::kNullId</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a41bf01a9bf40ee27f08405b404187235">Graph&lt; V, E, EdgeType &gt;::AddEdge()</a>.</p>

</div>
</div>
<a id="a13fd44a4e2a43ed903ea48ae9734c8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fd44a4e2a43ed903ea48ae9734c8b0">&#9670;&nbsp;</a></span>OutDegree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OutDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of edges incident from a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges incidents from a vertex. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#aa499ff4aa3cc5447d55b1942e14815af">Vertex&lt; V &gt;::Id()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">Graph&lt; V, E, EdgeType &gt;::VertexFromId()</a>.</p>

</div>
</div>
<a id="a40f7986cba7b23aa47a5d885547f67bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f7986cba7b23aa47a5d885547f67bd">&#9670;&nbsp;</a></span>OutDegree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OutDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of edges incident from a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex Id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of edges incidents from a vertex. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>.</p>

</div>
</div>
<a id="acded76285173462d9292a6e716854b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acded76285173462d9292a6e716854b26">&#9670;&nbsp;</a></span>RemoveEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> &amp;&#160;</td>
          <td class="paramname"><em>_edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an existing edge from the graph. After the removal, it won't be possible to reach any of the vertices from the edge, unless there are other edges that connect the to vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_edge</td><td>Id of the edge to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when the edge was removed or false otherwise. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/end.html">map&lt; K, T &gt;::end()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/erase.html">map&lt; K, T &gt;::erase()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/find.html">map&lt; K, T &gt;::find()</a>, and <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">gz::math::graph::kNullId</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a68247a4c93cc34ce189e8bed2aac6886">Graph&lt; V, E, EdgeType &gt;::RemoveEdge()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56fc2c300e17bb107b5118182dfb0099">Graph&lt; V, E, EdgeType &gt;::RemoveVertex()</a>.</p>

</div>
</div>
<a id="a68247a4c93cc34ce189e8bed2aac6886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68247a4c93cc34ce189e8bed2aac6886">&#9670;&nbsp;</a></span>RemoveEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveEdge </td>
          <td>(</td>
          <td class="paramtype">EdgeType &amp;&#160;</td>
          <td class="paramname"><em>_edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an existing edge from the graph. After the removal, it won't be possible to reach any of the vertices from the edge, unless there are other edges that connect the to vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_edge</td><td>The edge to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when the edge was removed or false otherwise. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#acded76285173462d9292a6e716854b26">Graph&lt; V, E, EdgeType &gt;::RemoveEdge()</a>.</p>

</div>
</div>
<a id="a56fc2c300e17bb107b5118182dfb0099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fc2c300e17bb107b5118182dfb0099">&#9670;&nbsp;</a></span>RemoveVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an existing vertex from the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>Id of the vertex to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when the vertex was removed or false otherwise. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/container/multimap/equal_range.html">multimap&lt; K, T &gt;::equal_range()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/multimap/erase.html">multimap&lt; K, T &gt;::erase()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#acded76285173462d9292a6e716854b26">Graph&lt; V, E, EdgeType &gt;::RemoveEdge()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1389cc1b2e80b835230deb2f0a9816a4">Graph&lt; V, E, EdgeType &gt;::RemoveVertex()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ababc7a882b46052d6e93f235f4cd6f19">Graph&lt; V, E, EdgeType &gt;::RemoveVertices()</a>.</p>

</div>
</div>
<a id="a1389cc1b2e80b835230deb2f0a9816a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1389cc1b2e80b835230deb2f0a9816a4">&#9670;&nbsp;</a></span>RemoveVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>_vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an existing vertex from the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_vertex</td><td>The vertex to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when the vertex was removed or false otherwise. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#aa499ff4aa3cc5447d55b1942e14815af">Vertex&lt; V &gt;::Id()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56fc2c300e17bb107b5118182dfb0099">Graph&lt; V, E, EdgeType &gt;::RemoveVertex()</a>.</p>

</div>
</div>
<a id="ababc7a882b46052d6e93f235f4cd6f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababc7a882b46052d6e93f235f4cd6f19">&#9670;&nbsp;</a></span>RemoveVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RemoveVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all vertices with name == _name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the vertices to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices removed. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/container/multimap/count.html">multimap&lt; K, T &gt;::count()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/multimap/find.html">multimap&lt; K, T &gt;::find()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a56fc2c300e17bb107b5118182dfb0099">Graph&lt; V, E, EdgeType &gt;::RemoveVertex()</a>.</p>

</div>
</div>
<a id="ad6ee1f29a7476ea70ed6e1f6618b0e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ee1f29a7476ea70ed6e1f6618b0e42">&#9670;&nbsp;</a></span>VertexFromId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt;V&gt;&amp; VertexFromId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mutable reference to a vertex using its Id. <p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>The Id of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable reference to the vertex with Id = _id or NullVertex if not found. </dd></dl>

</div>
</div>
<a id="a3424c0c193ab38d9f6cf7582a2fa0830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3424c0c193ab38d9f6cf7582a2fa0830">&#9670;&nbsp;</a></span>VertexFromId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt;V&gt;&amp; VertexFromId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to a vertex using its Id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>The Id of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the vertex with Id = _id or NullVertex if not found. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">Graph&lt; V, E, EdgeType &gt;::AdjacentsFrom()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ac5c3c5d658e6e209bd2df3ba9816488d">Graph&lt; V, E, EdgeType &gt;::AdjacentsTo()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">gz::math::graph::BreadthFirstSort()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">gz::math::graph::DepthFirstSort()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a6b0acb17e8c591dea2a66ff7693fcc17">Graph&lt; V, E, EdgeType &gt;::InDegree()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a13fd44a4e2a43ed903ea48ae9734c8b0">Graph&lt; V, E, EdgeType &gt;::OutDegree()</a>.</p>

</div>
</div>
<a id="a9e1d28212e2e3170856ef2c86f29c4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1d28212e2e3170856ef2c86f29c4a6">&#9670;&nbsp;</a></span>Vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt;V&gt; Vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collection of all vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A map of vertices, where keys are Ids and values are references to the vertices. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/ref.html">std::cref()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/emplace.html">map&lt; K, T &gt;::emplace()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">gz::math::graph::BreadthFirstSort()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a61a448fd0197b5e39056c6178a613619">gz::math::graph::ConnectedComponents()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">gz::math::graph::DepthFirstSort()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#aad10f204b8ee7e8cb0d24b4fa0fa52cb">gz::math::graph::Dijkstra()</a>, and <a class="el" href="namespacegz_1_1math_1_1graph.html#a9f5832ba872b12d625d3b7cd48d8144d">gz::math::graph::ToUndirectedGraph()</a>.</p>

</div>
</div>
<a id="a5ae1438d54d40ebc4df80206988bbfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae1438d54d40ebc4df80206988bbfd7">&#9670;&nbsp;</a></span>Vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a>&lt;V&gt; Vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collection of all vertices in the graph with name == _name. </p>
<dl class="section return"><dt>Returns</dt><dd>A map of vertices, where keys are Ids and values are references to the vertices. </dd></dl>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/ref.html">std::cref()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/emplace.html">map&lt; K, T &gt;::emplace()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2b6dc168e5adcb5cb871cf23de252f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6dc168e5adcb5cb871cf23de252f18">&#9670;&nbsp;</a></span>nextEdgeId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> nextEdgeId = 0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next edge Id to be assigned to a new edge. </p>

</div>
</div>
<a id="a0248262f6eabac11826e847018ac3ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0248262f6eabac11826e847018ac3ebb">&#9670;&nbsp;</a></span>nextVertexId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> nextVertexId = 0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The next vertex Id to be assigned to a new vertex. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gz_2math_2graph_2Graph_8hh_source.html">gz/math/graph/Graph.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>

