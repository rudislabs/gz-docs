<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Math">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Math: gz::math::graph Namespace Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Math</h1>
        <h2>API Reference</h2>
        <div class="version">
        7.5.1
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1math.html">math</a></li><li class="navelem"><a class="el" href="namespacegz_1_1math_1_1graph.html">graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gz::math::graph Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1DirectedEdge.html">DirectedEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A directed edge represents a connection between two vertices. The connection is unidirectional, it's only possible to traverse the edge in one direction (from the tail to the head).  <a href="classgz_1_1math_1_1graph_1_1DirectedEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic edge class. An edge has two ends and some constraint between them. For example, a directed edge only allows traversing the edge in one direction.  <a href="classgz_1_1math_1_1graph_1_1Edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgz_1_1math_1_1graph_1_1EdgeInitializer.html">EdgeInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in the <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html" title="A generic graph class. Both vertices and edges can store user information. A vertex could be created ...">Graph</a> constructors for uniform initialization.  <a href="structgz_1_1math_1_1graph_1_1EdgeInitializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic graph class. Both vertices and edges can store user information. A vertex could be created passing a custom Id if needed, otherwise it will be choosen internally. The vertices also have a name that could be reused among other vertices if needed. This class supports the use of different edge types (e.g. directed or undirected edges).  <a href="classgz_1_1math_1_1graph_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1UndirectedEdge.html">UndirectedEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An undirected edge represents a connection between two vertices. The connection is bidirectional, it's possible to traverse the edge in both directions.  <a href="classgz_1_1math_1_1graph_1_1UndirectedEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vertex of a graph. It stores user information, an optional name, and keeps an internal unique Id. This class does not enforce to choose a unique name.  <a href="classgz_1_1math_1_1graph_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8d46ec0a314990fb639a6789d9535cb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a8d46ec0a314990fb639a6789d9535cb7">CostInfo</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &gt;</td></tr>
<tr class="memdesc:a8d46ec0a314990fb639a6789d9535cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in Dijkstra. For a given source vertex, this pair represents the cost (first element) to reach a destination vertex (second element).  <a href="namespacegz_1_1math_1_1graph.html#a8d46ec0a314990fb639a6789d9535cb7">More...</a><br /></td></tr>
<tr class="separator:a8d46ec0a314990fb639a6789d9535cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdd9edb9244ce9627d193aba4ddb8bd"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E &gt; </td></tr>
<tr class="memitem:a7cdd9edb9244ce9627d193aba4ddb8bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a7cdd9edb9244ce9627d193aba4ddb8bd">DirectedGraph</a> = <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, <a class="el" href="classgz_1_1math_1_1graph_1_1DirectedEdge.html">DirectedEdge</a>&lt; E &gt; &gt;</td></tr>
<tr class="separator:a7cdd9edb9244ce9627d193aba4ddb8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7b937a5acbf171c4256ff5531df014"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> = uint64_t</td></tr>
<tr class="memdesc:a0e7b937a5acbf171c4256ff5531df014"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique Id for an edge.  <a href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">More...</a><br /></td></tr>
<tr class="separator:a0e7b937a5acbf171c4256ff5531df014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9380e6ff7c7ae575d4de5b6681b0a131"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a9380e6ff7c7ae575d4de5b6681b0a131">EdgeId_S</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a> &gt;</td></tr>
<tr class="separator:a9380e6ff7c7ae575d4de5b6681b0a131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92275c0c15cb546dfcd0fc5946fae1cb"><td class="memTemplParams" colspan="2">template&lt;typename EdgeType &gt; </td></tr>
<tr class="memitem:a92275c0c15cb546dfcd0fc5946fae1cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>&lt; const EdgeType &gt; &gt;</td></tr>
<tr class="separator:a92275c0c15cb546dfcd0fc5946fae1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6166b5982ebb3b70b794cbdd28aa4c94"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E &gt; </td></tr>
<tr class="memitem:a6166b5982ebb3b70b794cbdd28aa4c94"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a> = <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, <a class="el" href="classgz_1_1math_1_1graph_1_1UndirectedEdge.html">UndirectedEdge</a>&lt; E &gt; &gt;</td></tr>
<tr class="separator:a6166b5982ebb3b70b794cbdd28aa4c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7010c44b0824e6e2d08c537522e1a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> = uint64_t</td></tr>
<tr class="memdesc:a1f7010c44b0824e6e2d08c537522e1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique Id of each vertex.  <a href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">More...</a><br /></td></tr>
<tr class="separator:a1f7010c44b0824e6e2d08c537522e1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dc10e7b6811e71d1132c875014c18c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a88dc10e7b6811e71d1132c875014c18c">VertexId_P</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &gt;</td></tr>
<tr class="separator:a88dc10e7b6811e71d1132c875014c18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227b0188a2c9499b5cd9360568a2fc53"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a227b0188a2c9499b5cd9360568a2fc53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>&lt; const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt; V &gt; &gt;&gt;</td></tr>
<tr class="separator:a227b0188a2c9499b5cd9360568a2fc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b92ff00d2f2580a16823994b08a4022"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E , typename EdgeType &gt; </td></tr>
<tr class="memitem:a9b92ff00d2f2580a16823994b08a4022"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">BreadthFirstSort</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, EdgeType &gt; &amp;_graph, const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_from)</td></tr>
<tr class="memdesc:a9b92ff00d2f2580a16823994b08a4022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth first sort (BFS). Starting from the vertex == _from, it traverses the graph exploring the neighbors first, before moving to the next level neighbors.  <a href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">More...</a><br /></td></tr>
<tr class="separator:a9b92ff00d2f2580a16823994b08a4022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a448fd0197b5e39056c6178a613619"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E &gt; </td></tr>
<tr class="memitem:a61a448fd0197b5e39056c6178a613619"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a>&lt; V, E &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a61a448fd0197b5e39056c6178a613619">ConnectedComponents</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a>&lt; V, E &gt; &amp;_graph)</td></tr>
<tr class="memdesc:a61a448fd0197b5e39056c6178a613619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the connected components of an undirected graph. A connected component of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.  <a href="namespacegz_1_1math_1_1graph.html#a61a448fd0197b5e39056c6178a613619">More...</a><br /></td></tr>
<tr class="separator:a61a448fd0197b5e39056c6178a613619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a9e4cb88f8e7174917cac770fdda3d"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E , typename EdgeType &gt; </td></tr>
<tr class="memitem:a86a9e4cb88f8e7174917cac770fdda3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">DepthFirstSort</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, EdgeType &gt; &amp;_graph, const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_from)</td></tr>
<tr class="memdesc:a86a9e4cb88f8e7174917cac770fdda3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth first sort (DFS). Starting from the vertex == _from, it visits the graph as far as possible along each branch before backtracking.  <a href="namespacegz_1_1math_1_1graph.html#a86a9e4cb88f8e7174917cac770fdda3d">More...</a><br /></td></tr>
<tr class="separator:a86a9e4cb88f8e7174917cac770fdda3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad10f204b8ee7e8cb0d24b4fa0fa52cb"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E , typename EdgeType &gt; </td></tr>
<tr class="memitem:aad10f204b8ee7e8cb0d24b4fa0fa52cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a8d46ec0a314990fb639a6789d9535cb7">CostInfo</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#aad10f204b8ee7e8cb0d24b4fa0fa52cb">Dijkstra</a> (const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, EdgeType &gt; &amp;_graph, const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_from, const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;_to=<a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">kNullId</a>)</td></tr>
<tr class="memdesc:aad10f204b8ee7e8cb0d24b4fa0fa52cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dijkstra algorithm. Find the shortest path between the vertices in a graph. If only a graph and a source vertex is provided, the algorithm will find shortest paths from the source vertex to all other vertices in the graph. If an additional destination vertex is provided, the algorithm will stop when the shortest path is found between the source and destination vertex.  <a href="namespacegz_1_1math_1_1graph.html#aad10f204b8ee7e8cb0d24b4fa0fa52cb">More...</a><br /></td></tr>
<tr class="separator:aad10f204b8ee7e8cb0d24b4fa0fa52cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af245affa652023bbcc23dc79270a16e6"><td class="memTemplParams" colspan="2">template&lt;typename VV , typename EE &gt; </td></tr>
<tr class="memitem:af245affa652023bbcc23dc79270a16e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#af245affa652023bbcc23dc79270a16e6">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;_out, const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; VV, EE, <a class="el" href="classgz_1_1math_1_1graph_1_1DirectedEdge.html">DirectedEdge</a>&lt; EE &gt;&gt; &amp;_g)</td></tr>
<tr class="memdesc:af245affa652023bbcc23dc79270a16e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specification for directed edges.  <a href="namespacegz_1_1math_1_1graph.html#af245affa652023bbcc23dc79270a16e6">More...</a><br /></td></tr>
<tr class="separator:af245affa652023bbcc23dc79270a16e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ff61b8c394667edba82af1910b2d01"><td class="memTemplParams" colspan="2">template&lt;typename VV , typename EE &gt; </td></tr>
<tr class="memitem:a40ff61b8c394667edba82af1910b2d01"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a40ff61b8c394667edba82af1910b2d01">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;_out, const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; VV, EE, <a class="el" href="classgz_1_1math_1_1graph_1_1UndirectedEdge.html">UndirectedEdge</a>&lt; EE &gt;&gt; &amp;_g)</td></tr>
<tr class="memdesc:a40ff61b8c394667edba82af1910b2d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specification for undirected edges.  <a href="namespacegz_1_1math_1_1graph.html#a40ff61b8c394667edba82af1910b2d01">More...</a><br /></td></tr>
<tr class="separator:a40ff61b8c394667edba82af1910b2d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5832ba872b12d625d3b7cd48d8144d"><td class="memTemplParams" colspan="2">template&lt;typename V , typename E &gt; </td></tr>
<tr class="memitem:a9f5832ba872b12d625d3b7cd48d8144d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a>&lt; V, E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a9f5832ba872b12d625d3b7cd48d8144d">ToUndirectedGraph</a> (const <a class="el" href="namespacegz_1_1math_1_1graph.html#a7cdd9edb9244ce9627d193aba4ddb8bd">DirectedGraph</a>&lt; V, E &gt; &amp;_graph)</td></tr>
<tr class="memdesc:a9f5832ba872b12d625d3b7cd48d8144d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a DirectedGraph to an UndirectedGraph with the same vertices and edges.  <a href="namespacegz_1_1math_1_1graph.html#a9f5832ba872b12d625d3b7cd48d8144d">More...</a><br /></td></tr>
<tr class="separator:a9f5832ba872b12d625d3b7cd48d8144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6072871e8b2171f5fc136c763ace483a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">kNullId</a> = <a class="el" href="namespacegz_1_1math.html#a7e250ed5111e600d768a32edbc6b93d4">MAX_UI64</a></td></tr>
<tr class="memdesc:a6072871e8b2171f5fc136c763ace483a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an invalid Id.  <a href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">More...</a><br /></td></tr>
<tr class="separator:a6072871e8b2171f5fc136c763ace483a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8d46ec0a314990fb639a6789d9535cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d46ec0a314990fb639a6789d9535cb7">&#9670;&nbsp;</a></span>CostInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a8d46ec0a314990fb639a6789d9535cb7">CostInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in Dijkstra. For a given source vertex, this pair represents the cost (first element) to reach a destination vertex (second element). </p>

</div>
</div>
<a id="a7cdd9edb9244ce9627d193aba4ddb8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdd9edb9244ce9627d193aba4ddb8bd">&#9670;&nbsp;</a></span>DirectedGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegz_1_1math_1_1graph.html#a7cdd9edb9244ce9627d193aba4ddb8bd">DirectedGraph</a> =  <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt;V, E, <a class="el" href="classgz_1_1math_1_1graph_1_1DirectedEdge.html">DirectedEdge</a>&lt;E&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e7b937a5acbf171c4256ff5531df014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7b937a5acbf171c4256ff5531df014">&#9670;&nbsp;</a></span>EdgeId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unique Id for an edge. </p>

</div>
</div>
<a id="a9380e6ff7c7ae575d4de5b6681b0a131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9380e6ff7c7ae575d4de5b6681b0a131">&#9670;&nbsp;</a></span>EdgeId_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegz_1_1math_1_1graph.html#a9380e6ff7c7ae575d4de5b6681b0a131">EdgeId_S</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92275c0c15cb546dfcd0fc5946fae1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92275c0c15cb546dfcd0fc5946fae1cb">&#9670;&nbsp;</a></span>EdgeRef_M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegz_1_1math_1_1graph.html#a92275c0c15cb546dfcd0fc5946fae1cb">EdgeRef_M</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a0e7b937a5acbf171c4256ff5531df014">EdgeId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>&lt;const EdgeType&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6166b5982ebb3b70b794cbdd28aa4c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6166b5982ebb3b70b794cbdd28aa4c94">&#9670;&nbsp;</a></span>UndirectedGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a> =  <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt;V, E, <a class="el" href="classgz_1_1math_1_1graph_1_1UndirectedEdge.html">UndirectedEdge</a>&lt;E&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f7010c44b0824e6e2d08c537522e1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7010c44b0824e6e2d08c537522e1a0">&#9670;&nbsp;</a></span>VertexId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unique Id of each vertex. </p>

</div>
</div>
<a id="a88dc10e7b6811e71d1132c875014c18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dc10e7b6811e71d1132c875014c18c">&#9670;&nbsp;</a></span>VertexId_P</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegz_1_1math_1_1graph.html#a88dc10e7b6811e71d1132c875014c18c">VertexId_P</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a227b0188a2c9499b5cd9360568a2fc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227b0188a2c9499b5cd9360568a2fc53">&#9670;&nbsp;</a></span>VertexRef_M</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegz_1_1math_1_1graph.html#a227b0188a2c9499b5cd9360568a2fc53">VertexRef_M</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>&lt;const <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html">Vertex</a>&lt;V&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9b92ff00d2f2580a16823994b08a4022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b92ff00d2f2580a16823994b08a4022">&#9670;&nbsp;</a></span>BreadthFirstSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&gt; gz::math::graph::BreadthFirstSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, EdgeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breadth first sort (BFS). Starting from the vertex == _from, it traverses the graph exploring the neighbors first, before moving to the next level neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_graph</td><td>A graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_from</td><td>The starting vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector of vertices Ids traversed in a breadth first manner. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a41bf01a9bf40ee27f08405b404187235">Graph&lt; V, E, EdgeType &gt;::AddEdge()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a0d827829d28146a07586160b8addaccf">Graph&lt; V, E, EdgeType &gt;::AddVertex()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">Graph&lt; V, E, EdgeType &gt;::AdjacentsFrom()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a80c98ee28ae312d26adb03cd9b12363f">Graph&lt; V, E, EdgeType &gt;::Edges()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list/empty.html">list&lt; T &gt;::empty()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list/front.html">list&lt; T &gt;::front()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list/pop_front.html">list&lt; T &gt;::pop_front()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list/push_back.html">list&lt; T &gt;::push_back()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">vector&lt; T &gt;::push_back()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">Graph&lt; V, E, EdgeType &gt;::VertexFromId()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a9e1d28212e2e3170856ef2c86f29c4a6">Graph&lt; V, E, EdgeType &gt;::Vertices()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacegz_1_1math_1_1graph.html#a61a448fd0197b5e39056c6178a613619">ConnectedComponents()</a>.</p>

</div>
</div>
<a id="a61a448fd0197b5e39056c6178a613619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a448fd0197b5e39056c6178a613619">&#9670;&nbsp;</a></span>ConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a>&lt;V, E&gt; &gt; gz::math::graph::ConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a>&lt; V, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the connected components of an undirected graph. A connected component of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">https://en.wikipedia.org/wiki/Connected_component_(graph_theory)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_graph</td><td>A graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of graphs. Each element of the graph is a component (subgraph) of the original graph. </dd></dl>

<p class="reference">References <a class="el" href="namespacegz_1_1math_1_1graph.html#a9b92ff00d2f2580a16823994b08a4022">BreadthFirstSort()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a80c98ee28ae312d26adb03cd9b12363f">Graph&lt; V, E, EdgeType &gt;::Edges()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/end.html">map&lt; K, T &gt;::end()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map/find.html">map&lt; K, T &gt;::find()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a9e1d28212e2e3170856ef2c86f29c4a6">Graph&lt; V, E, EdgeType &gt;::Vertices()</a>.</p>

</div>
</div>
<a id="a86a9e4cb88f8e7174917cac770fdda3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a9e4cb88f8e7174917cac770fdda3d">&#9670;&nbsp;</a></span>DepthFirstSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>&gt; gz::math::graph::DepthFirstSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, EdgeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depth first sort (DFS). Starting from the vertex == _from, it visits the graph as far as possible along each branch before backtracking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_graph</td><td>A graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_from</td><td>The starting vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector of vertices Ids visited in a depth first manner. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a41bf01a9bf40ee27f08405b404187235">Graph&lt; V, E, EdgeType &gt;::AddEdge()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a0d827829d28146a07586160b8addaccf">Graph&lt; V, E, EdgeType &gt;::AddVertex()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">Graph&lt; V, E, EdgeType &gt;::AdjacentsFrom()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a80c98ee28ae312d26adb03cd9b12363f">Graph&lt; V, E, EdgeType &gt;::Edges()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">vector&lt; T &gt;::push_back()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/stack/top.html">stack&lt; T &gt;::top()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a3424c0c193ab38d9f6cf7582a2fa0830">Graph&lt; V, E, EdgeType &gt;::VertexFromId()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a9e1d28212e2e3170856ef2c86f29c4a6">Graph&lt; V, E, EdgeType &gt;::Vertices()</a>.</p>

</div>
</div>
<a id="aad10f204b8ee7e8cb0d24b4fa0fa52cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad10f204b8ee7e8cb0d24b4fa0fa52cb">&#9670;&nbsp;</a></span>Dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt;<a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a8d46ec0a314990fb639a6789d9535cb7">CostInfo</a>&gt; gz::math::graph::Dijkstra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; V, E, EdgeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> &amp;&#160;</td>
          <td class="paramname"><em>_to</em> = <code><a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">kNullId</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dijkstra algorithm. Find the shortest path between the vertices in a graph. If only a graph and a source vertex is provided, the algorithm will find shortest paths from the source vertex to all other vertices in the graph. If an additional destination vertex is provided, the algorithm will stop when the shortest path is found between the source and destination vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_graph</td><td>A graph. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_from</td><td>The starting vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_to</td><td>Optional destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where the keys are the destination vertices. For each destination, the value is another pair, where the key is the shortest cost from the origin vertex. The value is the previous neighbor Id in the shortest path. Note: In the case of providing a destination vertex, only the entry in the map with key = _to should be used. The rest of the map may contain incomplete information. If you want all shortest paths to all other vertices, please remove the destination vertex. If the source or destination vertex don't exist, the function will return an empty map.</dd></dl>
<p>E.g.: Given the following undirected graph, g, with five vertices: </p><pre class="fragment">         (6)                |
      0-------1             |
      |      /|\            |
      |     / | \&zwj;(5)        |
      | (2)/  |  \          |
      |   /   |   2         |
   (1)|  / (2)|  /          |
      | /     | /(5)        |
      |/      |/            |
      3-------4             |
         (1)                |
</pre><p> This is the resut of Dijkstra(g, 0):</p>
<div class="fragment"><div class="line">================================</div>
<div class="line">| Dst | Cost | Previous vertex |</div>
<div class="line">================================</div>
<div class="line">|  0  |  0   |        0        |</div>
<div class="line">|  1  |  3   |        3        |</div>
<div class="line">|  2  |  7   |        4        |</div>
<div class="line">|  3  |  1   |        0        |</div>
<div class="line">|  4  |  2   |        3        |</div>
<div class="line">================================</div>
</div><!-- fragment --><p>This is the result of Dijkstra(g, 0, 3):</p>
<div class="fragment"><div class="line">================================</div>
<div class="line">| Dst | Cost | Previous vertex |</div>
<div class="line">================================</div>
<div class="line">|  0  |  0   |        0        |</div>
<div class="line">|  1  |ignore|     ignore      |</div>
<div class="line">|  2  |ignore|     ignore      |</div>
<div class="line">|  3  |  1   |        0        |</div>
<div class="line">|  4  |ignore|     ignore      |</div>
<div class="line">================================</div>
</div><!-- fragment --> 
<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#a6072871e8b2171f5fc136c763ace483a">kNullId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair/make_pair.html">std::make_pair()</a>, <a class="el" href="namespacegz_1_1math.html#addeef129e4dae72dd32ec36a221c78f4">gz::math::MAX_D</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a9e1d28212e2e3170856ef2c86f29c4a6">Graph&lt; V, E, EdgeType &gt;::Vertices()</a>.</p>

</div>
</div>
<a id="af245affa652023bbcc23dc79270a16e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af245affa652023bbcc23dc79270a16e6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; gz::math::graph::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; VV, EE, <a class="el" href="classgz_1_1math_1_1graph_1_1DirectedEdge.html">DirectedEdge</a>&lt; EE &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial template specification for directed edges. </p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>.</p>

</div>
</div>
<a id="a40ff61b8c394667edba82af1910b2d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ff61b8c394667edba82af1910b2d01">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a>&amp; gz::math::graph::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html">Graph</a>&lt; VV, EE, <a class="el" href="classgz_1_1math_1_1graph_1_1UndirectedEdge.html">UndirectedEdge</a>&lt; EE &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial template specification for undirected edges. </p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>.</p>

</div>
</div>
<a id="a9f5832ba872b12d625d3b7cd48d8144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5832ba872b12d625d3b7cd48d8144d">&#9670;&nbsp;</a></span>ToUndirectedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1math_1_1graph.html#a6166b5982ebb3b70b794cbdd28aa4c94">UndirectedGraph</a>&lt;V, E&gt; gz::math::graph::ToUndirectedGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a7cdd9edb9244ce9627d193aba4ddb8bd">DirectedGraph</a>&lt; V, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a DirectedGraph to an UndirectedGraph with the same vertices and edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_graph</td><td>A directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An undirected graph with the same vertices and edges as the original graph. </dd></dl>

<p class="reference">References <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a80c98ee28ae312d26adb03cd9b12363f">Graph&lt; V, E, EdgeType &gt;::Edges()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">vector&lt; T &gt;::push_back()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a9e1d28212e2e3170856ef2c86f29c4a6">Graph&lt; V, E, EdgeType &gt;::Vertices()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6072871e8b2171f5fc136c763ace483a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6072871e8b2171f5fc136c763ace483a">&#9670;&nbsp;</a></span>kNullId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1math_1_1graph.html#a1f7010c44b0824e6e2d08c537522e1a0">VertexId</a> kNullId = <a class="el" href="namespacegz_1_1math.html#a7e250ed5111e600d768a32edbc6b93d4">MAX_UI64</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents an invalid Id. </p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a41bf01a9bf40ee27f08405b404187235">Graph&lt; V, E, EdgeType &gt;::AddEdge()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a0d827829d28146a07586160b8addaccf">Graph&lt; V, E, EdgeType &gt;::AddVertex()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a1b2df28d5a426724e36fde045a2398bf">Graph&lt; V, E, EdgeType &gt;::AdjacentsFrom()</a>, <a class="el" href="namespacegz_1_1math_1_1graph.html#aad10f204b8ee7e8cb0d24b4fa0fa52cb">Dijkstra()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1UndirectedEdge.html#a3b388f0e588feccafc684fa8b0cbaf7c">UndirectedEdge&lt; E &gt;::From()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1DirectedEdge.html#a3b388f0e588feccafc684fa8b0cbaf7c">DirectedEdge&lt; E &gt;::From()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#a75226801052d910550bb03bce6df8ab6">Graph&lt; V, E, EdgeType &gt;::IncidentsFrom()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#abd602eb002d37ae71e0b00d8ece51bc5">Graph&lt; V, E, EdgeType &gt;::IncidentsTo()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#ae5d8b54b2405f303d7b6f91879da183f">Graph&lt; V, E, EdgeType &gt;::LinkEdge()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Graph.html#acded76285173462d9292a6e716854b26">Graph&lt; V, E, EdgeType &gt;::RemoveEdge()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1DirectedEdge.html#a5bac1eb2b06d8a254d21e46600c3eb3d">DirectedEdge&lt; E &gt;::To()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Edge.html#a470438bf41ff0f2cc2fc41682c8f839e">Edge&lt; E &gt;::Valid()</a>, <a class="el" href="classgz_1_1math_1_1graph_1_1Vertex.html#a470438bf41ff0f2cc2fc41682c8f839e">Vertex&lt; V &gt;::Valid()</a>, and <a class="el" href="classgz_1_1math_1_1graph_1_1Edge.html#af13a627a30200b078b9b71a34ffe53ae">Edge&lt; E &gt;::Vertices()</a>.</p>

</div>
</div>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
